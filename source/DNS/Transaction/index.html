<!DOCTYPE html>
<html>
	<head>
		
			<title>DNS::Transaction</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../../_static/icon.png"/>
		<link rel="stylesheet" href="../../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../../_components/jquery/jquery.min.js"></script>
		<script src="../../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		
		<script src="../../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="../../../index.html">Project</a> › <a class="link" href="../../index.html">Source</a></header>
		
		<main>
			
	<h1><code class="language-ruby">DNS::Transaction</code></h1>
	
	<p>This class provides all details of a single DNS question and response. This is used by the DSL to provide DNS related functionality.</p>
<p>The main functions to complete the transaction are: <code class="language-ruby">#append!</code> (evaluate a new query and append the results), <code class="language-ruby">#passthrough!</code> (pass the query to an upstream server), <code class="language-ruby">#respond!</code> (compute a specific response) and <code class="language-ruby">#fail!</code> (fail with an error code).</p>
	
	
	<section>
	<h2>Definitions</h2>
	
	<section id="DNS::Transaction::DEFAULT_TTL"><h3><code class="language-ruby">DEFAULT_TTL = 86400</code></h3><p>The default time used for responses (24 hours).</p>
</section><section id="DNS::Transaction#resource_class"><h3><code class="language-ruby">attr :resource_class</code></h3><p>The resource_class that was requested. This is typically used to generate a response.</p>
</section><section id="DNS::Transaction#query"><h3><code class="language-ruby">attr :query</code></h3><p>The incoming query which is a set of questions.</p>
</section><section id="DNS::Transaction#question"><h3><code class="language-ruby">attr :question</code></h3><p>The question that this transaction represents.</p>
</section><section id="DNS::Transaction#response"><h3><code class="language-ruby">attr :response</code></h3><p>The current full response to the incoming query.</p>
</section><section id="DNS::Transaction#options"><h3><code class="language-ruby">attr :options</code></h3><p>Any options or configuration associated with the given transaction.</p>
</section><section id="DNS::Transaction#name"><h3><code class="language-ruby">def name</code></h3><p>The name of the question, which is typically the requested hostname.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def name
	@question.to_s
end</code></pre>
					</details></section><section id="DNS::Transaction#to_s"><h3><code class="language-ruby">def to_s</code></h3><p>Shows the question name and resource class. Suitable for debugging purposes.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def to_s
	&quot;#{name} #{@resource_class.name}&quot;
end</code></pre>
					</details></section><section id="DNS::Transaction#append!"><h3><code class="language-ruby">def append!(name, resource_class = nil, options = {})</code></h3><p>Run a new query through the rules with the given name and resource type. The results of this query are appended to the current transaction's <code>response</code>.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def append!(name, resource_class = nil, options = {})
	Transaction.new(@server, @query, name, resource_class || @resource_class, @response, options).process
end</code></pre>
					</details></section><section id="DNS::Transaction#passthrough!"><h3><code class="language-ruby">def passthrough!(resolver, options = {}, &amp;block)</code></h3><p>Use the given resolver to respond to the question. Uses <code>passthrough</code> to do the lookup and merges the result.</p>
<p>If a block is supplied, this function yields with the <code>response</code> message if successful. This could be used, for example, to update a cache or modify the reply.</p>
<p>If recursion is not requested, the result is <code>fail!(:Refused)</code>. This check is ignored if an explicit <code>options[:name]</code> or <code>options[:force]</code> is given.</p>
<p>If the resolver can't reach upstream servers, <code>fail!(:ServFail)</code> is invoked.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def passthrough!(resolver, options = {}, &amp;block)
	if @query.rd || options[:force] || options[:name]
		response = passthrough(resolver, options)
		
		if response
			yield response if block_given?
			
			# Recursion is available and is being used:
			# See issue #26 for more details.
			@response.ra = 1
			@response.merge!(response)
		else
			fail!(:ServFail)
		end
	else
		fail!(:Refused)
	end
end</code></pre>
					</details></section><section id="DNS::Transaction#passthrough"><h3><code class="language-ruby">def passthrough(resolver, options = {})</code></h3><p>Use the given resolver to respond to the question.</p>
<p>A block must be supplied, and provided a valid response is received from the upstream server, this function yields with the reply and reply_name.</p>
<p>If <code>options[:name]</code> is provided, this overrides the default query name sent to the upstream server. The same logic applies to <code>options[:resource_class]</code>.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def passthrough(resolver, options = {})
	query_name = options[:name] || name
	query_resource_class = options[:resource_class] || resource_class
	
	resolver.query(query_name, query_resource_class)
end</code></pre>
					</details></section><section id="DNS::Transaction#respond!"><h3><code class="language-ruby">def respond!(*args)</code></h3><p>The last argument can optionally be a hash of <code>options</code>. If <code>options[:resource_class]</code> is provided, it overrides the default resource class of transaction. Additional <code>options</code> are passed to <code class="language-ruby">#append!</code>.</p>
<p>See <code>Resolv::DNS::Resource</code> for more information about the various <code>resource_classes</code> available (http://www.ruby-doc.org/stdlib/libdoc/resolv/rdoc/index.html).</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def respond!(*args)
	append_question!
	
	options = args.last.kind_of?(Hash) ? args.pop : {}
	resource_class = options[:resource_class] || @resource_class
	
	if resource_class == nil
		raise ArgumentError.new(&quot;Could not instantiate resource #{resource_class}!&quot;)
	end
	
	resource = resource_class.new(*args)
	
	add([resource], options)
end</code></pre>
					</details></section><section id="DNS::Transaction#add"><h3><code class="language-ruby">def add(resources, options = {})</code></h3><p>Append a list of resources.</p>
<p>By default resources are appended to the <code>answers</code> section, but this can be changed by setting <code>options[:section]</code> to either <code>:authority</code> or <code>:additional</code>.</p>
<p>The time-to-live (TTL) of the resources can be specified using <code>options[:ttl]</code> and defaults to <code>DEFAULT_TTL</code>.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def add(resources, options = {})
	# Use the default options if provided:
	options = options.merge(@options)
	
	ttl = options[:ttl] || DEFAULT_TTL
	name = options[:name] || @question.to_s + &quot;.&quot;
	
	section = (options[:section] || 'answer').to_sym
	method = &quot;add_#{section}&quot;.to_sym
	
	resources.each do |resource|
		@server.logger.debug {&quot;#{method}: #{resource.inspect} #{resource.class::TypeValue} #{resource.class::ClassValue}&quot;}
		
		@response.send(method, name, ttl, resource)
	end
end</code></pre>
					</details></section><section id="DNS::Transaction#fail!"><h3><code class="language-ruby">def fail!(rcode)</code></h3><p>This function indicates that there was a failure to resolve the given question. The single argument must be an integer error code, typically given by the constants in <code class="language-ruby">Resolv::DNS::RCode</code>.</p>
<p>The easiest way to use this function it to simply supply a symbol. Here is a list of the most commonly used ones:</p>
<ul>
<li><code>:NoError</code>: No error occurred.</li>
<li><code>:FormErr</code>: The incoming data was not formatted correctly.</li>
<li><code>:ServFail</code>: The operation caused a server failure (internal error, etc).</li>
<li><code>:NXDomain</code>: Non-eXistant Domain (domain record does not exist).</li>
<li><code>:NotImp</code>: The operation requested is not implemented.</li>
<li><code>:Refused</code>: The operation was refused by the server.</li>
<li><code>:NotAuth</code>: The server is not authoritive for the zone.</li>
</ul>
<p>See <a href="http://www.rfc-editor.org/rfc/rfc2929.txt">RFC2929</a> for more information about DNS error codes (specifically, page 3).</p>
<p><strong>This function will complete deferred transactions.</strong></p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def fail!(rcode)
	append_question!
	
	if rcode.kind_of? Symbol
		@response.rcode = Resolv::DNS::RCode.const_get(rcode)
	else
		@response.rcode = rcode.to_i
	end
end</code></pre>
					</details></section><section id="DNS::Transaction#failure!"><h3><code class="language-ruby">def failure!(*args)</code></h3><details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def failure!(*args)
	@server.logger.warn &quot;failure! is deprecated, use fail! instead&quot;
	
	fail!(*args)
end</code></pre>
					</details></section><section id="DNS::Transaction#process"><h3><code class="language-ruby">def process</code></h3><p>A helper method to process the transaction on the given server. Unless the transaction is deferred, it will <code class="language-ruby">#succeed</code> on completion.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def process
	@server.process(name, @resource_class, self)
end</code></pre>
					</details></section><section id="DNS::Transaction#append_question!"><h3><code class="language-ruby">def append_question!</code></h3><p>A typical response to a DNS request includes both the question and response. This helper appends the question unless it looks like the user is already managing that aspect of the response.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def append_question!
	if @response.question.size == 0
		@response.add_question(@question, @resource_class)
	end
end</code></pre>
					</details></section>	</section>

				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>